
此语言（GM脚本基础结构）是以SCommand为基础 SCommandList为核心 分为量大部 Analy部和Runner部

SCommand结构：
stypeid [作为提供者的类型id] number
scguid [执行者id] sting
dataptr [命令参数结构指针，具体结构不定，由SCExec自行转换] void *
etypeid [作为请求者的类型id] number

SCommandList（简称CL）结构:
partb [CL参数符号表] dict
symtb [CL内部符号表] dict (先天具有self和parent成员)
symtb:self [CL对象自身对象符号表] dict 
symtb:parent [CL对象上级CL指针] SCommandList *[or dict * 暂未确定] (Run过程中通过此指针访问上级SCommandList的内部符号表)

SCExec结构：
exguid [与SCommand中的scguid对应用于得到解析SCommand的执行者] string
Run(SCValue *) [用于执行一个Command] 函数

符号类型有var local global
以及对 self.xxx的设置 属于命令列表专属变量

CL有参数表声明 参数表符号属于特殊符号

local 为本地符号 由analy直接转换为栈索引 只能在此CL中引用
var 为普通符号  存储在symtb中 可以由上级或下级（各层次）CL引用（多层通过parent.parent……或pof 关键字引用)
global 为全局符号 存储在Context的gstb中

Analy部：
Analy接受一系列SCRead对象存储于dict中 在处于一般模式（0）下时遇到任何非空字符都自动顺序获取其完整单词
并以单词为key从dict中获得SCRead对象指针
调用SCRead对象的GetRead函数得到解析后的SCommand对象顺序存储于SCommandList中 以及新的Index
从此index处继续解析
重复以上过程
得到完整的SCommandList

Runner部：
Runner接受一系列SCExec对象存储于dict中 在解析SCommandList时顺序获得SCommand对象 通过scguid得到SCexec对象
调用Run函数解析SCommand对象
注意：Run函数接受一个SCValue对象指针  此对象指针可以为空具体视SCommand的etypeid而定 
若stypeid不为0 则表示提供一个对应的变量作为提供变量
若etypeid不为0 则表示接收一个对应的变量作为请求变量

若解析一个命令时遇到etypeid不为0 则自动递归调用自身解析下一个Command 若下一个Command的stypeid和此command的
stypeid不相等 则执行错误(执行时检查方案 我更倾向于解析时检查方案)

SCValue结构:
name [类型名] string
dataptr [数据指针] void *
len [数据大小] uint32_t
ptrsum [引用计数] uint32_t
metadata [元数据] dict  string->SCVal

SCValue代表一个数据对象的实体 不同的符号可以有同一个SCValue指针
每多一个对SCValue的符号引用引用计数自动加1

注意：SCValue的实体存储在堆中
其他位置存储的SCValue都是指针
任何符号表都是string->SCvalue * 的键值对
每建立一个对SCValue的指针 就使SCValue实体中的引用计数加1 包括local变量

local变量将SCValue指针存在栈中 通过栈索引引用
其他变量将SCValue指针存放在符号表中 通过key引用

对引用计数的操作由具体SCExec执行 因此由具体指令决定
